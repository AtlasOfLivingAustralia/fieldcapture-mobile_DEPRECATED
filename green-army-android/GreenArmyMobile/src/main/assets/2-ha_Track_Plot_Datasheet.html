

<!DOCTYPE html>
<head>
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <script src="static/t5OGphSUjwdNOoxNKgdRTTh1RBtmzhMXxHDYYeR4lYj.js" type="text/javascript" ></script>
<link href="static/090onaZX1M508oSWqGmMeETZ9NkUA9p4CCTW3MUpRPc.css" type="text/css" rel="stylesheet" media="screen, projection" />

<link href="static/VySgOjkVOsD8Jt8ujXROVRjZeDLAAwVhMF5WqPZ8Ajf.css" type="text/css" rel="stylesheet" media="screen, projection" />
<link href="http://www.ala.org.au/wp-content/themes/ala2011/images/favicon.ico" rel="shortcut icon" />
<!--[if lt IE 9]><script src="static/Yh1Txee3hFzExJ4P1str7tGV24zQMEYtxqtlYJ5ukR0.js" type="text/javascript" ></script><![endif]-->
<link href="static/Qwaw257M4sHcJuspEDRbeQoTceByqRmOCHNaZWpOxuc.css" type="text/css" rel="stylesheet" media="screen, projection" />
<link href="static/AcXIjLTuc87n8sfxBjJRQSoBIUwP9RnCyK8Sv82i7eV.css" type="text/css" rel="stylesheet" media="screen, projection" />
<link href="static/doSKUivnfI9gXmPKZ2XG4W5xIABYgKaf5Dwf3LtjNVr.css" type="text/css" rel="stylesheet" media="screen, projection" />
<link href="static/fx5pGfEFSRJi6nyez3s8fUsjDL8WJ0IB04Njm7T2VAJ.css" type="text/css" rel="stylesheet" media="all" />
<link href="static/qBQAxqnczDqd7Bl7B2gXgLoB51xIPPVo3q06lXUPLcy.css" type="text/css" rel="stylesheet" media="screen,print" />




<link href="static/KYGDEVRRaKjNbTXJkHmicmzo9vFrnnzCnGLcxKjR04f.css" type="text/css" rel="stylesheet" media="screen,print" />

<link href="static/KtHosYDw6qHDklqhUqI9Y0lrV4QlbtokVSWtoN5CyvP.css" type="text/css" rel="stylesheet" media="screen,print" />
<link href="static/nq5UnIyX5LhMaOWVShAJhQHKHVGPAbNeKmoHiJNIGvz.css" type="text/css" rel="stylesheet" media="screen, projection" />
<link href="/static/RrjzrZ0Ci0GPLETIr8x8KUMjfJtZKvifrUtMCedwKRB.png" rel="shortcut icon" />
<link href="static/4zsVqykqBON8U5Es5kfffXBSGJlbI8VrPDW4hSn1SWJ.css" type="text/css" rel="stylesheet" media="screen, projection" />


<link href="static/sCFm7bBsIMFGQHTSlBbhMHQCXWhOsbBr5z4bu1OueIE.css" type="text/css" rel="stylesheet" media="screen, projection" />
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" type="text/css" rel="stylesheet" media="screen, projection" />
<link href="static/tUELnv7Uvq6ppWNUWOlaow3JGSTTIf8hJ2VYvh7Oahj.css" type="text/css" rel="stylesheet" media="screen, projection" />
<link href="/static/OKcRcjAeA1yuXD9r4fZA1Uw2HEwL7gYvjc6HdrZXIYP.png" rel="shortcut icon" />
<link href="/static/UxF0saaqmikaj74l2WFcCyPMm9hEEs8if7IBy0GNAnd.png" rel="shortcut icon" />
<link href="/static/zs4hrJqt7I802RlaZiXbmbDBarpNPZF8V8fCQJ2RVTM.png" rel="shortcut icon" />
<link href="/static/SvC1e8bSiCPFh8mObbEThgbJIaGZi72ATzqobK6QnnB.gif" rel="shortcut icon" />
<link href="/static/BA9MhIHZnH0zMcKJWIWsTurHhQTpDYE6akqM5excaZI.gif" rel="shortcut icon" />

<script type="text/javascript">
    var fcConfig = {
        bieUrl: "http://bie.ala.org.au",
        speciesProfileUrl: "https://fieldcapture.ala.org.au/proxy/speciesProfile",
        googleStaticUrl:"http://maps.googleapis.com/maps/api/staticmap?maptype=terrian&zoom=12&sensor=false&size=350x250&markers=color:red%7C"
        },
        here = document.location.href;
    </script>
    

    <meta name="layout" content="mobile"/>

    
    
    
</if>

    <style type="text/css">
        input[type=checkbox] {  -webkit-transform: scale(1.5); }
        .checkbox-list label { min-height: 40px; }
        .speciesAutocompleteRow {min-height:40px;}
        .datepicker td, .datepicker th {
            width:40px;
            height:40px;
            vertical-align: middle;
        }
    </style>
</head>

<body>

<div id="content" class="clearfix">
    
<div class="container-fluid validationEngineContainer" id="validation-container">
<div id="koActivityMainBlock">

    <div class="row-fluid">
        <div class="span12">
            <!-- Common activity fields -->

            <div class="row-fluid space-after">
                <div class="span4">

                    <label class="for-readonly">Type</label>
                    <span class="readonly-text" data-bind="text:type"></span>
                </div>
                <div class="span8">

                    <label class="for-readonly">Description</label>
                    <span class="readonly-text" data-bind="text:description"></span>
                </div>
            </div>


            <div class="row-fluid space-after">
                <div class="span4">
                    <label class="for-readonly inline">Planned start date</label>
                    <span class="readonly-text" data-bind="text:plannedStartDate.formattedDate"></span>
                </div>
                <div class="span8">
                    <label class="for-readonly inline">Planned end date</label>
                    <span class="readonly-text" data-bind="text:plannedEndDate.formattedDate"></span>
                </div>
            </div>

            <div class="well">
                <div class="row-fluid">

                    <span class="span8">
                    <div class="row-fluid space-after">

                        <div class="span6 required">
                            <label for="startDate"><b>Actual start date</b>
                                <a href='#' class='helphover' data-original-title='' data-placement='top' data-content='Date the activity was started.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a>
                            </label>


                            <div class="input-append">
                                <input data-bind='datepicker:startDate.date' name='startDate' id='startDate' type='text' size='16' class='input-xlarge' readonly='readonly' targetField='startDate.date' data-validation-engine='validate[required]' />
<span class='add-on open-datepicker'>
  <i class='icon-th'>&nbsp;</i>
</span>
                            </div>

                        </div>
                        <div class="span6" data-bind="css:{required:transients.markedAsFinished}">
                            <label for="endDate"><b>Actual end date</b>
                                <a href='#' class='helphover' data-original-title='' data-placement='top' data-content='Date the activity finished.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a>
                            </label>

                            <div class="input-append">
                                <input data-bind='datepicker:endDate.date' name='endDate' id='endDate' type='text' size='16' class='input-xlarge' readonly='readonly' targetField='endDate.date' data-validation-engine='validate[future[startDate]]' />
<span class='add-on open-datepicker'>
  <i class='icon-th'>&nbsp;</i>
</span>
                            </div>

                        </div>
                    </div>
                    <div class="row-fluid space-after">
                        <div class="span6">
                            <label for="theme"><b>Major theme</b></label>
                            <select id="theme" data-bind="value:mainTheme, options:transients.themes, optionsCaption:'Choose..'" class="input-xlarge" style="width:90%">
                            </select>
                        </div>

                        <div class="span6">
                            <label><b>Progress</b></label>
                            <label for="activityComplete"><input type="checkbox" id="activityComplete" data-bind="checked:transients.markedAsFinished" style="margin-right:1em;"><span>This activity is complete</span></label>

                        </div>

                    </div>
                    <div class="row-fluid">
                        <div class="span6">
                            <label for="site"><b>Site</b></label>
                            <select id='site' style='width:90%' data-bind='options:transients.sites,optionsText:"name",optionsValue:"siteId",value:siteId,optionsCaption:"Choose a site..."'>&nbsp;</select>

                        </div>

                        <div class="span3">

                            <button class="btn btn-info" style="margin-top:25px;" data-bind="visible:transients.newSiteSupported,click:createNewSite">Create new Site</button>
                        </div>
                    </div>

                    
                        
                            
                                
                            
                            
                                
                                    
                                    
                                    
                                    

                                
                            
                        

                    
                    </span>
                    <span class="span4">

                        <img id="siteLocationImage" width="100%" data-bind="event:{error:siteLoadError}, attr:{src:transients.siteImgUrl}, visible:transients.siteImgUrl()"/>


                    </span>
                </div>
            </div>
        </div>
    </div>

</div>

<!-- ko stopBinding: true -->

    
    
    
    <style type="text/css">
        table.vegTypeTableOverstorey th {white-space:normal;}
        table.vegTypeTableOverstorey tbody td:nth-child(1) {width:30%;}
        table.vegTypeTableOverstorey tbody td:nth-child(2) {width:45%;}
        table.vegTypeTableOverstorey tbody td:nth-child(3) {width:15%;text-align:center;}
        table.vegTypeTableOverstorey td:last-child {width:4%;text-align:center;}
        table.vegTypeTableOverstorey textarea {width:100%; box-sizing:border-box; }
        table.vegTypeTableOverstorey select {width:100%; box-sizing:border-box; }
    </style><style type="text/css">
        table.vegTypeTableUnderstorey th {white-space:normal;}
        table.vegTypeTableUnderstorey tbody td:nth-child(1) {width:30%;}
        table.vegTypeTableUnderstorey tbody td:nth-child(2) {width:45%;}
        table.vegTypeTableUnderstorey tbody td:nth-child(3) {width:15%;text-align:center;}
        table.vegTypeTableUnderstorey td:last-child {width:4%;text-align:center;}
        table.vegTypeTableUnderstorey textarea {width:100%; box-sizing:border-box; }
        table.vegTypeTableUnderstorey select {width:100%; box-sizing:border-box; }
    </style><style type="text/css">
        table.trackingSurfaceSuitabilityTable th {white-space:normal;}
        table.trackingSurfaceSuitabilityTable tbody td:nth-child(1) {width:60%;}
        table.trackingSurfaceSuitabilityTable tbody td:nth-child(2) {width:40%;text-align:center;}
        table.trackingSurfaceSuitabilityTable td:last-child {width:4%;text-align:center;}
        table.trackingSurfaceSuitabilityTable textarea {width:100%; box-sizing:border-box; }
        table.trackingSurfaceSuitabilityTable select {width:100%; box-sizing:border-box; }
    </style><style type="text/css">
        table.sightingEvidenceTable th {white-space:normal;}
        table.sightingEvidenceTable tbody td:nth-child(1) {width:15%;}
        table.sightingEvidenceTable tbody td:nth-child(2) {width:5%;text-align:center;}
        table.sightingEvidenceTable tbody td:nth-child(3) {width:5%;text-align:center;}
        table.sightingEvidenceTable tbody td:nth-child(4) {width:5%;text-align:center;}
        table.sightingEvidenceTable tbody td:nth-child(5) {width:5%;text-align:center;}
        table.sightingEvidenceTable tbody td:nth-child(6) {width:5%;text-align:center;}
        table.sightingEvidenceTable tbody td:nth-child(7) {width:10%;}
        table.sightingEvidenceTable tbody td:nth-child(8) {width:10%;}
        table.sightingEvidenceTable tbody td:nth-child(9) {width:15%;}
        table.sightingEvidenceTable td:last-child {width:4%;text-align:center;}
        table.sightingEvidenceTable textarea {width:100%; box-sizing:border-box; }
        table.sightingEvidenceTable select {width:100%; box-sizing:border-box; }
    </style>
    <div class="output-block" id="ko2-ha_Track_Plot_Method">
            <h3 data-bind="css:{modified:dirtyFlag.isDirty},attr:{title:'Has been modified'}">2-ha Track Plot Method</h3>
        <div data-bind="if:transients.optional">
            <label class="checkbox" ><input type="checkbox" data-bind="checked:outputNotCompleted"> <span data-bind="text:transients.questionText"></span> </label>
        </div>
        <div id="2-ha_Track_Plot_Method-content" data-bind="visible:!outputNotCompleted()">
        <!-- add the dynamic components -->
            <div class="row-fluid space-after output-section" >
<div class="span6">
<div class="row-fluid"><span class="span12">    <span  class="span8"><h3>Event Information</h3></span></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel required"><label>Observer name<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='The name of the person who submitted/created the record in the database.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></label></span><input  class="span8 input-small" data-bind='value:data.recordedBy'  data-validation-engine='validate[required]' type='text' class='input-small'/></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>Observer name(s)<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='The name of the person(s) who undertook the field work to create the record.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></label></span><input  class="span8 input-small" data-bind='value:data.collectedBy'  type='text' class='input-small'/></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel required"><label>Survey date<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='The date on which the sighting was made.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></label></span><div class="input-append"><input data-bind="datepicker:data.surveyDate.date" type="text" size="12" data-validation-engine='validate[required]'/><span class="add-on open-datepicker"><i class="icon-th"></i></span></div></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel required"><label>Survey start time<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='The time at which the survey commenced.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></label></span></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>Survey finish time<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='The time at which the survey finished.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></label></span></span></div><div class="row-fluid"><span class="span12">    <span  class="span8"><h3>Datum & Location</h3></span></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>Map zone</label></span><select class="span8" data-bind='value:data.zone,options:transients.zoneConstraints,optionsCaption:"Please select"' data-validation-engine='validate[custom[number],min[0]]'></select></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>Easting<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='The easting of the centroid of the survey area.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></label></span><input class="input-small" style="text-align:center" data-bind='value:data.easting' data-validation-engine='validate[custom[number],min[0]]' type='number' class='input-mini'/></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>Northing<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='The northing of the centroid of the survey area.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></label></span><input class="input-small" style="text-align:center" data-bind='value:data.northing' data-validation-engine='validate[custom[number],min[0]]' type='number' class='input-mini'/></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel required"><label>Distance and direction from nearest named place<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='Indicate the distance from the plot to the nearest named place or locality.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></label></span><input  class="span8 input-small" data-bind='value:data.relativeLocation'  data-validation-engine='validate[required]' type='text' class='input-small'/></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>Distance from watersource (km)<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='Indicate the distance of the plot from the nearest permanent water source.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></label></span><input class="input-small" style="text-align:center" data-bind='value:data.distanceFromWater' data-validation-engine='validate[custom[number],min[0]]' type='number' class='input-mini'/></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>Distance from vehicle track/road (km)<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='Indicate the distance of the plot from the nearest vehicle track or road.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></label></span><input class="input-small" style="text-align:center" data-bind='value:data.distanceFromRoad' data-validation-engine='validate[custom[number],min[0]]' type='number' class='input-mini'/></span></div><div class="row-fluid"><span class="span12">    <span  class="span8"><h3>Site details</h3></span></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>Habitat<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='What is the main type of habitat being sampled in this plot? If &apos;Other&apos;, please specify.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></label></span><select class="span8" data-bind='value:data.habitatType,options:transients.habitatTypeConstraints,optionsCaption:"Please select"'></select></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>Other habitat type (please specify)</label></span><input  class="span8 input-small" data-bind='value:data.habitatTypeOther'  type='text' class='input-small'/></span></div><div class="row-fluid ">
            <table class="table table-bordered vegTypeTableOverstorey " >
                <thead><tr><th>Overstorey vegetation</th><th>Description</th><th>% Cover</th><th></th>
                </tr></thead>
                <tbody data-bind="template:{name:'vegTypeTableOverstoreyviewTmpl', foreach: data.vegTypeTableOverstorey}"></tbody>
                <script id="vegTypeTableOverstoreyviewTmpl" type="text/html"><tr>
                    <td><span  data-bind='text:vegTypeOverstorey'></span></td>
                    <td><textarea  data-bind='value:vegDescriptionOverstorey'></textarea></td>
                    <td><select data-bind='value:percentCoverOverstorey,options:transients.percentCoverOverstoreyConstraints,optionsCaption:"Please select"' data-validation-engine='validate[custom[number],min[0]]'></select></td>
                    <td><i data-bind='click:$root.removevegTypeTableOverstoreyRow' class='icon-remove'></i></td>
                </tr></script>
                <tfoot>
<tr><td colspan="4">
            <div class="text-left" style="margin:5px">
                <a data-bind="click:downloadvegTypeTableOverstoreyTemplateWithData" class="btn"><i class="fa fa-download"></i> Download the data from this table (.xlsx)</a>
            </div>
            </tr>                </tfoot>
            </table>
        </div>
<div class="row-fluid ">
            <table class="table table-bordered vegTypeTableUnderstorey " >
                <thead><tr><th>Understorey vegetation</th><th>Description</th><th>% Cover</th><th></th>
                </tr></thead>
                <tbody data-bind="template:{name:'vegTypeTableUnderstoreyviewTmpl', foreach: data.vegTypeTableUnderstorey}"></tbody>
                <script id="vegTypeTableUnderstoreyviewTmpl" type="text/html"><tr>
                    <td><span  data-bind='text:vegTypeUnderstorey'></span></td>
                    <td><textarea  data-bind='value:vegDescriptionUnderstorey'></textarea></td>
                    <td><select data-bind='value:percentCoverUnderstorey,options:transients.percentCoverUnderstoreyConstraints,optionsCaption:"Please select"' data-validation-engine='validate[custom[number],min[0]]'></select></td>
                    <td><i data-bind='click:$root.removevegTypeTableUnderstoreyRow' class='icon-remove'></i></td>
                </tr></script>
                <tfoot>
<tr><td colspan="4">
            <div class="text-left" style="margin:5px">
                <a data-bind="click:downloadvegTypeTableUnderstoreyTemplateWithData" class="btn"><i class="fa fa-download"></i> Download the data from this table (.xlsx)</a>
            </div>
            </tr>                </tfoot>
            </table>
        </div>
<div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>Ephemeral or annual vegetation</label></span><select class="span8" data-bind='value:data.ephemeralVegPresent,options:transients.ephemeralVegPresentConstraints,optionsCaption:"Please select"'></select></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel required"><label>Time since strong wind/rain</label></span><select class="span8" data-bind='value:data.timeSinceWeatherEvent,options:transients.timeSinceWeatherEventConstraints,optionsCaption:"Please select"' data-validation-engine='validate[required]'></select></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel required"><label>Time since fire (if known)</label></span><select class="span8" data-bind='value:data.timeSinceFire,options:transients.timeSinceFireConstraints,optionsCaption:"Please select"' data-validation-engine='validate[required]'></select></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel required"><label>Visibility</label></span><select class="span8" data-bind='value:data.visibility,options:transients.visibilityConstraints,optionsCaption:"Please select"' data-validation-engine='validate[required]'></select></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>Length of shadow as a percentage of your own actual height</label></span><input class="input-small" style="text-align:center" data-bind='value:data.shadowLength' data-validation-engine='validate[min[0],custom[number]]' type='number' class='input-mini'/></span></div></div><div class="span6">
<div class="row-fluid"><span class="span12">    <span  class="span8"><i>Zoom into the map, click on the marker and click on the map at your survey site to place it. Select the 'Worldimagery' base layer for more detail. Alternatively, enter the lat/long coordinates (WGS84 decimal) below the map.</i></span></span></div><div class="row-fluid"><span class="span12">    </span></div><div class="row-fluid"><span class="span12">    <span  class="span8"><h3>Tracking Surface Condition</h3></span></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>How good is the tracking surface overall?</label></span><select class="span8" data-bind='value:data.trackingSurface,options:transients.trackingSurfaceConstraints,optionsCaption:"Please select"'></select></span></div><div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>What percentage of the total plot area is actually suitable for tracking?</label></span><input class="input-small" style="text-align:center" data-bind='value:data.trackingSurfaceSuitability' data-validation-engine='validate[min[0],max[100],custom[number]]' type='number' class='input-mini'/></span></div><div class="row-fluid ">
            <table class="table table-bordered trackingSurfaceSuitabilityTable " >
                <thead><tr><th>Tracking Suitability Category</th><th>% of plot suitable for tracking along path taken</th><th></th>
                </tr></thead>
                <tbody data-bind="template:{name:'trackingSurfaceSuitabilityTableviewTmpl', foreach: data.trackingSurfaceSuitabilityTable}"></tbody>
                <script id="trackingSurfaceSuitabilityTableviewTmpl" type="text/html"><tr>
                    <td><span  data-bind='text:trackingSurfaceSuitabilityCategory'></span></td>
                    <td><input class="input-large" style="text-align:center" data-bind='value:percentOfPlotSuitable' data-validation-engine='validate[min[0],max[100],custom[number]]' type='number' class='input-mini'/></td>
                    <td><i data-bind='click:$root.removetrackingSurfaceSuitabilityTableRow' class='icon-remove'></i></td>
                </tr></script>
                <tfoot>
<tr><td colspan="3">
            <div class="text-left" style="margin:5px">
                <a data-bind="click:downloadtrackingSurfaceSuitabilityTableTemplateWithData" class="btn"><i class="fa fa-download"></i> Download the data from this table (.xlsx)</a>
            </div>
            </tr>                </tfoot>
            </table>
        </div>
<div class="row-fluid"><span class="span12">    <span  class="span4 preLabel"><label>How continuous is the best tracking surface?</label></span><select class="span8" data-bind='value:data.trackingSurfaceContinuity,options:transients.trackingSurfaceContinuityConstraints,optionsCaption:"Please select"'></select></span></div></div></div>
<div class="row-fluid space-after " >
<span class="span12">    <span  class="span12"><h3>Evidence of species presence</h3></span></span></div>
<div class="row-fluid space-after " >
<span class="span12">    <span  class="span12"><i>Please add a row for each species for which evidence has been observed.</i></span></span></div>
<div class="row-fluid space-after output-section" >
<div class="row-fluid ">
            <table class="table table-bordered sightingEvidenceTable " >
                <thead><tr><th class="required">Species (start typing common or scientific name)<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='The species name of the animal (or tracks/evidence of) observed.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></th><th class="required">Track imprints on plot</th><th class="required">Track imprints on adjacent road/track</th><th>Animal (or skeletal remains)</th><th>Burrows/diggings</th><th>Scats</th><th>Abundance of all signs (1,2,3)</th><th class="required">Age of most recent signs</th><th>Comments, measurements,juvenile signs, etc.<a href='#' class='helphover' data-original-title='' data-placement='top' data-content='Observation notes about the record.'>
  <i class='icon-question-sign'>&nbsp;</i>
</a></th><th></th>
                </tr></thead>
                <tbody data-bind="template:{name:'sightingEvidenceTableviewTmpl', foreach: data.sightingEvidenceTable}"></tbody>
                <script id="sightingEvidenceTableviewTmpl" type="text/html"><tr>
                    <td>
<span class="input-prepend input-append" data-bind="with:species">
    <span class="add-on" data-bind="visible:!transients.editing(), css:{'btn-success':name()}"><i class="icon-white" data-bind="css:{'icon-ok':listId()!='unmatched' && name(), 'icon-question-sign':listId()=='unmatched' || listId() == 'error-unmatched'}"></i></span><span class="add-on" data-bind="visible:transients.editing()"><img src="static/Xo2jbaJ5EFqa59u9g4c4ybpCpw3wFWKhQdzZwNmmktO.gif" alt="saving icon" /></span><input type="text" data-bind="value:transients.textFieldValue,event:{focusout:focusLost},autocomplete:{url:'https://fieldcapture.ala.org.au/search/species', render: renderItem, listId: list, result:speciesSelected, valueChangeCallback:textFieldChanged}"  data-validation-engine='validate[required]'/>
    <span class="add-on" data-bind="visible: !transients.editing() && name()">
        <a href="#" data-bind="popover: {title: name, content: transients.speciesInformation}"><i class="icon-info-sign"></i></a>
    </span>
</span>
</td>
                    <td><input name='tracksOnPlot' data-bind='checked:tracksOnPlot' data-validation-engine='validate[required]' type='checkbox' class='checkbox'/></td>
                    <td><input name='tracksAdjacent' data-bind='checked:tracksAdjacent' data-validation-engine='validate[required]' type='checkbox' class='checkbox'/></td>
                    <td><input name='animalObserved' data-bind='checked:animalObserved' type='checkbox' class='checkbox'/></td>
                    <td><input name='diggingsObserved' data-bind='checked:diggingsObserved' type='checkbox' class='checkbox'/></td>
                    <td><input name='scatsObserved' data-bind='checked:scatsObserved' type='checkbox' class='checkbox'/></td>
                    <td><select data-bind='value:abundanceClass,options:transients.abundanceClassConstraints,optionsCaption:"Please select"'></select></td>
                    <td><select data-bind='value:evidenceAgeClass,options:transients.evidenceAgeClassConstraints,optionsCaption:"Please select"' data-validation-engine='validate[required]'></select></td>
                    <td><textarea  data-bind='value:comments'></textarea></td>
                    <td><i data-bind='click:$root.removesightingEvidenceTableRow' class='icon-remove'></i></td>
                </tr></script>
                <tfoot>
                <tr><td colspan="10" style="text-align:left;">
                        <button type="button" class="btn btn-small" data-bind="click:addsightingEvidenceTableRow">
                        <i class="icon-plus"></i> Add a row</button></td></tr> <script id="sightingEvidenceTabletemplate-upload" type="text/x-tmpl">{% %}</script>
                       <script id="sightingEvidenceTabletemplate-download" type="text/x-tmpl">{% %}</script>                </tfoot>
            </table>
        </div>
</div>

        </div>
        


        
    </div>
    

<!-- /ko -->

</div>




</div>

<script src="static/jNGzWep9YTzJQCsSRDWGKonJ7ycvNMNQauAe6AcGX4T.js" type="text/javascript" ></script>





<script src="static/5zeDycYZFxJsfDd3W1kuhrN47XnIMrbhS6gdHDvcExv.js" type="text/javascript" ></script>

<script src="static/ulxBmo4RrKTNT3DuFHethb4EOZpwQfvefxNXivDIbzp.js" type="text/javascript" ></script>








<!--[if gte IE 8]><script src="static/knxjs4G9Cquc79O3iYW107XikPB1Z1ii8QWrtBpzlSP.js" type="text/javascript" ></script><![endif]-->
<script src="static/nRrltgvxdEHd5BqRR1v4XU3ZStOrhDScuH03g4r8E6O.js" type="text/javascript" ></script>

<script src="static/iRQrJhH2zDlUTI4nXr10v5JHksIJyPjoe8fHSE4QZcI.js" type="text/javascript" ></script>

<script src="static/NsIfUsVWId7YD36PcnVeycNW6GCdIRgD7cdnhiQldmM.js" type="text/javascript" ></script>









<script src="static/IZCc6ZgD3MepYbz4UqlDLzMDNNghSCivcfGebmF9V2d.js" type="text/javascript" ></script>
<script src="static/NwE7QStklZyP86Oe5o9TUAwbaHqgfflXARrIBoL6Q5s.js" type="text/javascript" ></script>




<script src="static/e9gGniNN5cG3OR4oPVWd5lYoxE5Xf282hFe7d4FTQbq.js" type="text/javascript" ></script>


<script src="static/CRNxISj7t7ZCV7B8M8dFtBK7x7R4tGVO36INoBz8gQX.js" type="text/javascript" ></script>

<script src="static/QhlSgFWjl35vcaCRa5cKxHZxRWSSluzptQUKz3PHr9s.js" type="text/javascript" ></script>


<script src="static/8WCQyXwicnBgTdLQ4F5jUFtmVXmqG9eUZKvo74wOnIT.js" type="text/javascript" ></script>
<script src="static/9HtLc6nfgO9H72LVVZxetW45ZR623Fx8EhEdydgOq2F.js" type="text/javascript" ></script>
<script src="static/wkrwT3eqoZlWXFPCQRTvkdsdvwzT5Lw2H89f9eTkQdb.js" type="text/javascript" ></script>


<script type="text/javascript">
    
    // load dynamic models - usually objects in a list
            var Output_2haTrackPlotMethod_vegTypeTableOverstoreyRow = function (data) {
            var self = this;
            if (!data) data = {};
            self.transients = {};
            this.vegTypeOverstorey = ko.observable(orBlank(data['vegTypeOverstorey']));
            this.vegDescriptionOverstorey = ko.observable(orBlank(data['vegDescriptionOverstorey']));
            this.percentCoverOverstorey = ko.observable(orZero(data['percentCoverOverstorey'])).extend({numericString:2});
            self.transients.percentCoverOverstoreyConstraints = ["<1%","1-5%","6-25%",">25%"];
        };
        var Output_2haTrackPlotMethod_vegTypeTableUnderstoreyRow = function (data) {
            var self = this;
            if (!data) data = {};
            self.transients = {};
            this.vegTypeUnderstorey = ko.observable(orBlank(data['vegTypeUnderstorey']));
            this.vegDescriptionUnderstorey = ko.observable(orBlank(data['vegDescriptionUnderstorey']));
            this.percentCoverUnderstorey = ko.observable(orZero(data['percentCoverUnderstorey'])).extend({numericString:2});
            self.transients.percentCoverUnderstoreyConstraints = ["<5%","5-10%","11-30%",">30%"];
        };
        var Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow = function (data) {
            var self = this;
            if (!data) data = {};
            self.transients = {};
            this.trackingSurfaceSuitabilityCategory = ko.observable(orBlank(data['trackingSurfaceSuitabilityCategory']));
            this.percentOfPlotSuitable = ko.observable(orZero(data['percentOfPlotSuitable'])).extend({numericString:2});
        };
        var Output_2haTrackPlotMethod_sightingEvidenceTableRow = function (data) {
            var self = this;
            if (!data) data = {};
            self.transients = {};
            this.species =  new SpeciesViewModel(data['species'], speciesLists, {printable:''});
            this.tracksOnPlot = ko.observable(orFalse(data['tracksOnPlot']));
            this.tracksAdjacent = ko.observable(orFalse(data['tracksAdjacent']));
            this.animalObserved = ko.observable(orFalse(data['animalObserved']));
            this.diggingsObserved = ko.observable(orFalse(data['diggingsObserved']));
            this.scatsObserved = ko.observable(orFalse(data['scatsObserved']));
            this.abundanceClass = ko.observable(orBlank(data['abundanceClass']));
            self.transients.abundanceClassConstraints = ["1 - Signs in all four quarters of plot","2 - Signs in half to 3/4 of quarters of plot","3 - One individual only or signs only found in 1/4 of plot"];
            this.evidenceAgeClass = ko.observable(orBlank(data['evidenceAgeClass']));
            self.transients.evidenceAgeClassConstraints = ["1 - 1-2 days old","2 - 3 days to 1 week","3 - Imprinted in mud or hard substrate, older than 1 week"];
            this.comments = ko.observable(orBlank(data['comments']));
        };
        var speciesLists = [];
        var site = {};


    window["ViewModel"] = function (output, site, config) {
        var self = this;
        if (!output) {
            output = {};
        }
        var activityId = output.activityId || config.activityId || '';
        self.name = "";
        self.outputId = orBlank(output.outputId);

        self.data = {};
        self.transients = {};
        var notCompleted = output.outputNotCompleted;

        if (notCompleted === undefined) {
            notCompleted = config.collapsedByDefault;
        }

        self.transients.selectedSite = ko.observable(site);
        self.outputNotCompleted = ko.observable(notCompleted);
        self.transients.optional = config.optional || false;
        self.transients.questionText = config.optionalQuestionText || 'Not applicable';
        self.transients.dummy = ko.observable();

        self.downloadDataTemplate = function(listName) {
            var data = ko.mapping.toJS(self.data[listName](), {ignore:['transients']});
            var params = {
                listName:listName,
                type:self.name,
                data:JSON.stringify(data)
            };
            var url = '/activity/excelOutputTemplate';
            $.fileDownload(url, {
                httpMethod:'POST',
                data:params
            });

        };


        // add declarations for dynamic data
        
            self.data.recordedBy = ko.observable();

            self.data.collectedBy = ko.observable();

            self.data.surveyDate = ko.observable().extend({simpleDate: false});

            self.data.plotId = ko.observable();

            self.data.sampleType = ko.observable();
            self.transients.sampleTypeConstraints = ["Opportunistic","Systematic","Targeted (for particular species)"];

            self.data.sampleSequence = ko.observable();
            self.transients.sampleSequenceConstraints = ["Initial sample","Repeat sample"];

            self.data.zone = ko.observable().extend({numericString:2});
            self.transients.zoneConstraints = ["49","50","51","52","53","54","55"];

            self.data.easting = ko.observable().extend({numericString:2});

            self.data.northing = ko.observable().extend({numericString:2});

            self.data.relativeLocation = ko.observable();

            self.data.distanceFromWater = ko.observable().extend({numericString:2});

            self.data.distanceFromRoad = ko.observable().extend({numericString:2});

            self.data.habitatType = ko.observable();
            self.transients.habitatTypeConstraints = ["Sand dune","Sand plain","Creek line","Other"];

            self.data.habitatTypeOther = ko.observable();

            self.data.vegTypeTableOverstorey = ko.observableArray([]);
            self.selectedvegTypeTableOverstoreyRow = ko.observable();
        

            self.loadvegTypeTableOverstorey = function (data, append) {
                if (!append) {
                    self.data.vegTypeTableOverstorey([]);
                }
                if (data === undefined) {
                                        self.data.vegTypeTableOverstorey.push(new Output_2haTrackPlotMethod_vegTypeTableOverstoreyRow({"vegTypeOverstorey":"Main overstorey vegetation type","percentCoverOverstorey":"","vegDescriptionOverstorey":""}));
                } else {
                    $.each(data, function (i, obj) {
                        self.data.vegTypeTableOverstorey.push(new Output_2haTrackPlotMethod_vegTypeTableOverstoreyRow(obj));
                    });
                }
            };
            self.downloadvegTypeTableOverstoreyTemplateWithData = function() {
                self.downloadDataTemplate('vegTypeTableOverstorey');
            }

            self.addvegTypeTableOverstoreyRow = function () {
                var newRow = new Output_2haTrackPlotMethod_vegTypeTableOverstoreyRow();
                self.data.vegTypeTableOverstorey.push(newRow);
                
            };
            self.removevegTypeTableOverstoreyRow = function (row) {
                self.data.vegTypeTableOverstorey.remove(row);
                
            };
            self.vegTypeTableOverstoreyrowCount = function () {
                return self.data.vegTypeTableOverstorey().length;
            };

            self.vegTypeTableOverstoreyTableDataUploadVisible = ko.observable(false);
            self.showvegTypeTableOverstoreyTableDataUpload = function() {
                self.vegTypeTableOverstoreyTableDataUploadVisible(!self.vegTypeTableOverstoreyTableDataUploadVisible());
            };

            self.templateDownloadUrl = function(type) {
                return '/proxy/excelOutputTemplate?listName=vegTypeTableOverstorey&type=';
            }

            self.vegTypeTableOverstoreyTableDataUploadOptions = {
                    url:'/activity/ajaxUpload',
                    done:function(e, data) {
                        if (data.result.error) {
                            self.uploadFailed(data.result.error);
                        }
                        else {
                            self.loadvegTypeTableOverstorey(data.result.data, self.appendTableRows());
                        }
                    },
                    fail:function(e, data) {
                        var message = 'Please contact MERIT support and attach your spreadsheet to help us resolve the problem';
                        self.uploadFailed(data);

                    },
                    uploadTemplateId: "vegTypeTableOverstoreytemplate-upload",
                    downloadTemplateId: "vegTypeTableOverstoreytemplate-download",
                    formData:{type:'null', listName:'vegTypeTableOverstorey'}
            };
            self.appendTableRows = ko.observable(true);
            self.uploadFailed = function(message) {
                        var text = "<span class='label label-important'>Important</span><h4>There was an error uploading your data.</h4>";
                        text += "<p>"+message+"</p>";
                        bootbox.alert(text)
            };

            self.data.vegTypeTableUnderstorey = ko.observableArray([]);
            self.selectedvegTypeTableUnderstoreyRow = ko.observable();
        

            self.loadvegTypeTableUnderstorey = function (data, append) {
                if (!append) {
                    self.data.vegTypeTableUnderstorey([]);
                }
                if (data === undefined) {
                                        self.data.vegTypeTableUnderstorey.push(new Output_2haTrackPlotMethod_vegTypeTableUnderstoreyRow({"percentCoverUnderstorey":"","vegTypeUnderstorey":"Main understorey vegetation type","vegDescriptionUnderstorey":""}));
                } else {
                    $.each(data, function (i, obj) {
                        self.data.vegTypeTableUnderstorey.push(new Output_2haTrackPlotMethod_vegTypeTableUnderstoreyRow(obj));
                    });
                }
            };
            self.downloadvegTypeTableUnderstoreyTemplateWithData = function() {
                self.downloadDataTemplate('vegTypeTableUnderstorey');
            }

            self.addvegTypeTableUnderstoreyRow = function () {
                var newRow = new Output_2haTrackPlotMethod_vegTypeTableUnderstoreyRow();
                self.data.vegTypeTableUnderstorey.push(newRow);
                
            };
            self.removevegTypeTableUnderstoreyRow = function (row) {
                self.data.vegTypeTableUnderstorey.remove(row);
                
            };
            self.vegTypeTableUnderstoreyrowCount = function () {
                return self.data.vegTypeTableUnderstorey().length;
            };

            self.vegTypeTableUnderstoreyTableDataUploadVisible = ko.observable(false);
            self.showvegTypeTableUnderstoreyTableDataUpload = function() {
                self.vegTypeTableUnderstoreyTableDataUploadVisible(!self.vegTypeTableUnderstoreyTableDataUploadVisible());
            };

            self.templateDownloadUrl = function(type) {
                return '/proxy/excelOutputTemplate?listName=vegTypeTableUnderstorey&type=';
            }

            self.vegTypeTableUnderstoreyTableDataUploadOptions = {
                    url:'/activity/ajaxUpload',
                    done:function(e, data) {
                        if (data.result.error) {
                            self.uploadFailed(data.result.error);
                        }
                        else {
                            self.loadvegTypeTableUnderstorey(data.result.data, self.appendTableRows());
                        }
                    },
                    fail:function(e, data) {
                        var message = 'Please contact MERIT support and attach your spreadsheet to help us resolve the problem';
                        self.uploadFailed(data);

                    },
                    uploadTemplateId: "vegTypeTableUnderstoreytemplate-upload",
                    downloadTemplateId: "vegTypeTableUnderstoreytemplate-download",
                    formData:{type:'null', listName:'vegTypeTableUnderstorey'}
            };
            self.appendTableRows = ko.observable(true);
            self.uploadFailed = function(message) {
                        var text = "<span class='label label-important'>Important</span><h4>There was an error uploading your data.</h4>";
                        text += "<p>"+message+"</p>";
                        bootbox.alert(text)
            };

            self.data.ephemeralVegPresent = ko.observable();
            self.transients.ephemeralVegPresentConstraints = ["Present","Absent"];

            self.data.timeSinceWeatherEvent = ko.observable();
            self.transients.timeSinceWeatherEventConstraints = ["0 h","<6 h","6-12 h","12.01-24 h",">24 h","Unknown"];

            self.data.timeSinceFire = ko.observable();
            self.transients.timeSinceFireConstraints = ["1-2 years","3-5 years","6-10 years",">10 years","Unknown"];

            self.data.visibility = ko.observable();
            self.transients.visibilityConstraints = ["Distinct shadow","Slight shadow","No shadow"];

            self.data.shadowLength = ko.observable().extend({numericString:2});

            self.data.trackingSurface = ko.observable();
            self.transients.trackingSurfaceConstraints = ["3 - If present, you would be able to distinguish camel, human, dingo, emu or kangaroo tracks only","2 - If present, you would be able to distinguish all of 3 plus fox, cat, rabbit, echidna, large reptiles and goannas","1 - If present, you would be able to distinguish 2 + 3 plus hopping mice, rodent, small bird, insect, etc."];

            self.data.trackingSurfaceSuitability = ko.observable().extend({numericString:2});

            self.data.trackingSurfaceSuitabilityTable = ko.observableArray([]);
            self.selectedtrackingSurfaceSuitabilityTableRow = ko.observable();
        

            self.loadtrackingSurfaceSuitabilityTable = function (data, append) {
                if (!append) {
                    self.data.trackingSurfaceSuitabilityTable([]);
                }
                if (data === undefined) {
                                        self.data.trackingSurfaceSuitabilityTable.push(new Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow({"trackingSurfaceSuitabilityCategory":"Category 1 - could distinguish tracks of category 2 & 3 animals, plus hopping mice, rodents, small birds, insects etc","percentOfPlotSuitable":""}));
                    self.data.trackingSurfaceSuitabilityTable.push(new Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow({"trackingSurfaceSuitabilityCategory":"Category 2 - could distinguish tracks of category 3 animals, plus fox, cat, rabbit, echidna, goannas","percentOfPlotSuitable":""}));
                    self.data.trackingSurfaceSuitabilityTable.push(new Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow({"trackingSurfaceSuitabilityCategory":"Category 3 - could distinguish tracks of camel, dingo, human, emu or kangaroo","percentOfPlotSuitable":""}));
                    self.data.trackingSurfaceSuitabilityTable.push(new Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow({"trackingSurfaceSuitabilityCategory":"Category 4 - no tracks of any animals could be distinguished","percentOfPlotSuitable":""}));
                } else {
                    $.each(data, function (i, obj) {
                        self.data.trackingSurfaceSuitabilityTable.push(new Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow(obj));
                    });
                }
            };
            self.downloadtrackingSurfaceSuitabilityTableTemplateWithData = function() {
                self.downloadDataTemplate('trackingSurfaceSuitabilityTable');
            }

            self.addtrackingSurfaceSuitabilityTableRow = function () {
                var newRow = new Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow();
                self.data.trackingSurfaceSuitabilityTable.push(newRow);
                
            };
            self.removetrackingSurfaceSuitabilityTableRow = function (row) {
                self.data.trackingSurfaceSuitabilityTable.remove(row);
                
            };
            self.trackingSurfaceSuitabilityTablerowCount = function () {
                return self.data.trackingSurfaceSuitabilityTable().length;
            };

            self.trackingSurfaceSuitabilityTableTableDataUploadVisible = ko.observable(false);
            self.showtrackingSurfaceSuitabilityTableTableDataUpload = function() {
                self.trackingSurfaceSuitabilityTableTableDataUploadVisible(!self.trackingSurfaceSuitabilityTableTableDataUploadVisible());
            };

            self.templateDownloadUrl = function(type) {
                return '/proxy/excelOutputTemplate?listName=trackingSurfaceSuitabilityTable&type=';
            }

            self.trackingSurfaceSuitabilityTableTableDataUploadOptions = {
                    url:'/activity/ajaxUpload',
                    done:function(e, data) {
                        if (data.result.error) {
                            self.uploadFailed(data.result.error);
                        }
                        else {
                            self.loadtrackingSurfaceSuitabilityTable(data.result.data, self.appendTableRows());
                        }
                    },
                    fail:function(e, data) {
                        var message = 'Please contact MERIT support and attach your spreadsheet to help us resolve the problem';
                        self.uploadFailed(data);

                    },
                    uploadTemplateId: "trackingSurfaceSuitabilityTabletemplate-upload",
                    downloadTemplateId: "trackingSurfaceSuitabilityTabletemplate-download",
                    formData:{type:'null', listName:'trackingSurfaceSuitabilityTable'}
            };
            self.appendTableRows = ko.observable(true);
            self.uploadFailed = function(message) {
                        var text = "<span class='label label-important'>Important</span><h4>There was an error uploading your data.</h4>";
                        text += "<p>"+message+"</p>";
                        bootbox.alert(text)
            };

            self.data.trackingSurfaceContinuity = ko.observable();
            self.transients.trackingSurfaceContinuityConstraints = ["3 - Majority of sandy patches less than 1m in width","2 - Majority of sandy patches 1-3m in width","1 - Majority of sandy patches more than 3m in width"];

            self.data.sightingEvidenceTable = ko.observableArray([]);
            self.selectedsightingEvidenceTableRow = ko.observable();
        

            self.loadsightingEvidenceTable = function (data, append) {
                if (!append) {
                    self.data.sightingEvidenceTable([]);
                }
                if (data === undefined) {
                    self.addsightingEvidenceTableRow();
                } else {
                    $.each(data, function (i, obj) {
                        self.data.sightingEvidenceTable.push(new Output_2haTrackPlotMethod_sightingEvidenceTableRow(obj));
                    });
                }
            };
            self.downloadsightingEvidenceTableTemplateWithData = function() {
                self.downloadDataTemplate('sightingEvidenceTable');
            }

            self.addsightingEvidenceTableRow = function () {
                var newRow = new Output_2haTrackPlotMethod_sightingEvidenceTableRow();
                self.data.sightingEvidenceTable.push(newRow);
                
            };
            self.removesightingEvidenceTableRow = function (row) {
                self.data.sightingEvidenceTable.remove(row);
                
            };
            self.sightingEvidenceTablerowCount = function () {
                return self.data.sightingEvidenceTable().length;
            };

            self.sightingEvidenceTableTableDataUploadVisible = ko.observable(false);
            self.showsightingEvidenceTableTableDataUpload = function() {
                self.sightingEvidenceTableTableDataUploadVisible(!self.sightingEvidenceTableTableDataUploadVisible());
            };

            self.templateDownloadUrl = function(type) {
                return '/proxy/excelOutputTemplate?listName=sightingEvidenceTable&type=';
            }

            self.sightingEvidenceTableTableDataUploadOptions = {
                    url:'/activity/ajaxUpload',
                    done:function(e, data) {
                        if (data.result.error) {
                            self.uploadFailed(data.result.error);
                        }
                        else {
                            self.loadsightingEvidenceTable(data.result.data, self.appendTableRows());
                        }
                    },
                    fail:function(e, data) {
                        var message = 'Please contact MERIT support and attach your spreadsheet to help us resolve the problem';
                        self.uploadFailed(data);

                    },
                    uploadTemplateId: "sightingEvidenceTabletemplate-upload",
                    downloadTemplateId: "sightingEvidenceTabletemplate-download",
                    formData:{type:'null', listName:'sightingEvidenceTable'}
            };
            self.appendTableRows = ko.observable(true);
            self.uploadFailed = function(message) {
                        var text = "<span class='label label-important'>Important</span><h4>There was an error uploading your data.</h4>";
                        text += "<p>"+message+"</p>";
                        bootbox.alert(text)
            };
            self.transients.site = site;

        // this will be called when generating a savable model to remove transient properties
        self.removeBeforeSave = function (jsData) {
            // add code to remove any transients added by the dynamic tags
            
            delete jsData.activityType;
            delete jsData.transients;
            return jsData;
        };

        // this returns a JS object ready for saving
        self.modelForSaving = function () {
            // get model as a plain javascript object
            var jsData = ko.mapping.toJS(self, {'ignore':['transients']});
            if (self.outputNotCompleted()) {
                jsData.data = {};
            }

            // get rid of any transient observables
            return self.removeBeforeSave(jsData);
        };

        // this is a version of toJSON that just returns the model as it will be saved
        // it is used for detecting when the model is modified (in a way that should invoke a save)
        // the ko.toJSON conversion is preserved so we can use it to view the active model for debugging
        self.modelAsJSON = function () {
            return JSON.stringify(self.modelForSaving());
        };

        self.loadData = function (data, documents) {
            // load dynamic data
                            self.data['recordedBy'](data['recordedBy']);
                self.data['collectedBy'](data['collectedBy']);
                self.data['surveyDate'](data['surveyDate']);
                self.data['plotId'](data['plotId']);
                self.data['sampleType'](data['sampleType']);
                self.data['sampleSequence'](data['sampleSequence']);
                self.data['zone'](orZero(data['zone']));
                self.data['easting'](orZero(data['easting']));
                self.data['northing'](orZero(data['northing']));
                self.data['relativeLocation'](data['relativeLocation']);
                self.data['distanceFromWater'](orZero(data['distanceFromWater']));
                self.data['distanceFromRoad'](orZero(data['distanceFromRoad']));
                self.data['habitatType'](data['habitatType']);
                self.data['habitatTypeOther'](data['habitatTypeOther']);
                self.loadvegTypeTableOverstorey(data.vegTypeTableOverstorey);
                self.loadvegTypeTableUnderstorey(data.vegTypeTableUnderstorey);
                self.data['ephemeralVegPresent'](data['ephemeralVegPresent']);
                self.data['timeSinceWeatherEvent'](data['timeSinceWeatherEvent']);
                self.data['timeSinceFire'](data['timeSinceFire']);
                self.data['visibility'](data['visibility']);
                self.data['shadowLength'](orZero(data['shadowLength']));
                self.data['trackingSurface'](data['trackingSurface']);
                self.data['trackingSurfaceSuitability'](orZero(data['trackingSurfaceSuitability']));
                self.loadtrackingSurfaceSuitabilityTable(data.trackingSurfaceSuitabilityTable);
                self.data['trackingSurfaceContinuity'](data['trackingSurfaceContinuity']);
                self.loadsightingEvidenceTable(data.sightingEvidenceTable);


            // if there is no data in tables then add an empty row for the user to add data
            if (typeof self.addRow === 'function' && self.rowCount() === 0) {
                self.addRow();
            }
            self.transients.dummy.notifySubscribers();
        };

        self.attachDocument = function(target) {
            var url = config.documentUpdateUrl || fcConfig.documentUpdateUrl;
            showDocumentAttachInModal(url, new DocumentViewModel({role:'information', stage:config.stage},{activityId:activityId, projectId:config.projectId}), '#attachDocument')
                    .done(function(result) {
                        target(new DocumentViewModel(result))
                    });
        };
        self.editDocumentMetadata = function(document) {
            var url = (config.documentUpdateUrl || fcConfig.documentUpdateUrl) + "/" + document.documentId;
            showDocumentAttachInModal(url, document, '#attachDocument');
        };
        self.deleteDocument = function(document) {
            document.status('deleted');
            var url = (config.documentDeleteUrl || fcConfig.documentDeleteUrl)+'/'+document.documentId;
            $.post(url, {}, function() {});

        };
    };
</script><script type="text/javascript">
        $(function(){

            var viewModelName = "2-ha_Track_Plot_MethodViewModel",
                viewModelInstance = viewModelName + "Instance";

            // load dynamic models - usually objects in a list
                    var Output_2haTrackPlotMethod_vegTypeTableOverstoreyRow = function (data) {
            var self = this;
            if (!data) data = {};
            self.transients = {};
            this.vegTypeOverstorey = ko.observable(orBlank(data['vegTypeOverstorey']));
            this.vegDescriptionOverstorey = ko.observable(orBlank(data['vegDescriptionOverstorey']));
            this.percentCoverOverstorey = ko.observable(orZero(data['percentCoverOverstorey'])).extend({numericString:2});
            self.transients.percentCoverOverstoreyConstraints = ["<1%","1-5%","6-25%",">25%"];
        };
        var Output_2haTrackPlotMethod_vegTypeTableUnderstoreyRow = function (data) {
            var self = this;
            if (!data) data = {};
            self.transients = {};
            this.vegTypeUnderstorey = ko.observable(orBlank(data['vegTypeUnderstorey']));
            this.vegDescriptionUnderstorey = ko.observable(orBlank(data['vegDescriptionUnderstorey']));
            this.percentCoverUnderstorey = ko.observable(orZero(data['percentCoverUnderstorey'])).extend({numericString:2});
            self.transients.percentCoverUnderstoreyConstraints = ["<5%","5-10%","11-30%",">30%"];
        };
        var Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow = function (data) {
            var self = this;
            if (!data) data = {};
            self.transients = {};
            this.trackingSurfaceSuitabilityCategory = ko.observable(orBlank(data['trackingSurfaceSuitabilityCategory']));
            this.percentOfPlotSuitable = ko.observable(orZero(data['percentOfPlotSuitable'])).extend({numericString:2});
        };
        var Output_2haTrackPlotMethod_sightingEvidenceTableRow = function (data) {
            var self = this;
            if (!data) data = {};
            self.transients = {};
            this.species =  new SpeciesViewModel(data['species'], speciesLists, {printable:''});
            this.tracksOnPlot = ko.observable(orFalse(data['tracksOnPlot']));
            this.tracksAdjacent = ko.observable(orFalse(data['tracksAdjacent']));
            this.animalObserved = ko.observable(orFalse(data['animalObserved']));
            this.diggingsObserved = ko.observable(orFalse(data['diggingsObserved']));
            this.scatsObserved = ko.observable(orFalse(data['scatsObserved']));
            this.abundanceClass = ko.observable(orBlank(data['abundanceClass']));
            self.transients.abundanceClassConstraints = ["1 - Signs in all four quarters of plot","2 - Signs in half to 3/4 of quarters of plot","3 - One individual only or signs only found in 1/4 of plot"];
            this.evidenceAgeClass = ko.observable(orBlank(data['evidenceAgeClass']));
            self.transients.evidenceAgeClassConstraints = ["1 - 1-2 days old","2 - 3 days to 1 week","3 - Imprinted in mud or hard substrate, older than 1 week"];
            this.comments = ko.observable(orBlank(data['comments']));
        };
        var speciesLists = [];
        var site = {};


            this[viewModelName] = function (output, config) {
                var self = this;
                self.name = "2-ha Track Plot Method";
                self.outputId = orBlank(output.outputId);

                self.data = {};
                self.transients = {};
                var notCompleted = output.outputNotCompleted;

                if (notCompleted === undefined) {
                    notCompleted = config.collapsedByDefault;
                }
                self.transients.selectedSite = ko.observable(site);
                self.outputNotCompleted = ko.observable(notCompleted);
                self.transients.optional = config.optional || false;
                self.transients.questionText = config.optionalQuestionText || 'Not applicable';
                self.transients.dummy = ko.observable();

                // add declarations for dynamic data
                
            self.data.recordedBy = ko.observable();

            self.data.collectedBy = ko.observable();

            self.data.surveyDate = ko.observable().extend({simpleDate: false});

            self.data.plotId = ko.observable();

            self.data.sampleType = ko.observable();
            self.transients.sampleTypeConstraints = ["Opportunistic","Systematic","Targeted (for particular species)"];

            self.data.sampleSequence = ko.observable();
            self.transients.sampleSequenceConstraints = ["Initial sample","Repeat sample"];

            self.data.zone = ko.observable().extend({numericString:2});
            self.transients.zoneConstraints = ["49","50","51","52","53","54","55"];

            self.data.easting = ko.observable().extend({numericString:2});

            self.data.northing = ko.observable().extend({numericString:2});

            self.data.relativeLocation = ko.observable();

            self.data.distanceFromWater = ko.observable().extend({numericString:2});

            self.data.distanceFromRoad = ko.observable().extend({numericString:2});

            self.data.habitatType = ko.observable();
            self.transients.habitatTypeConstraints = ["Sand dune","Sand plain","Creek line","Other"];

            self.data.habitatTypeOther = ko.observable();

            self.data.vegTypeTableOverstorey = ko.observableArray([]);
            self.selectedvegTypeTableOverstoreyRow = ko.observable();
        

            self.loadvegTypeTableOverstorey = function (data, append) {
                if (!append) {
                    self.data.vegTypeTableOverstorey([]);
                }
                if (data === undefined) {
                                        self.data.vegTypeTableOverstorey.push(new Output_2haTrackPlotMethod_vegTypeTableOverstoreyRow({"vegTypeOverstorey":"Main overstorey vegetation type","percentCoverOverstorey":"","vegDescriptionOverstorey":""}));
                } else {
                    $.each(data, function (i, obj) {
                        self.data.vegTypeTableOverstorey.push(new Output_2haTrackPlotMethod_vegTypeTableOverstoreyRow(obj));
                    });
                }
            };
            self.downloadvegTypeTableOverstoreyTemplateWithData = function() {
                self.downloadDataTemplate('vegTypeTableOverstorey');
            }

            self.addvegTypeTableOverstoreyRow = function () {
                var newRow = new Output_2haTrackPlotMethod_vegTypeTableOverstoreyRow();
                self.data.vegTypeTableOverstorey.push(newRow);
                
            };
            self.removevegTypeTableOverstoreyRow = function (row) {
                self.data.vegTypeTableOverstorey.remove(row);
                
            };
            self.vegTypeTableOverstoreyrowCount = function () {
                return self.data.vegTypeTableOverstorey().length;
            };

            self.vegTypeTableOverstoreyTableDataUploadVisible = ko.observable(false);
            self.showvegTypeTableOverstoreyTableDataUpload = function() {
                self.vegTypeTableOverstoreyTableDataUploadVisible(!self.vegTypeTableOverstoreyTableDataUploadVisible());
            };

            self.templateDownloadUrl = function(type) {
                return '/proxy/excelOutputTemplate?listName=vegTypeTableOverstorey&type=2-ha+Track+Plot+Method';
            }

            self.vegTypeTableOverstoreyTableDataUploadOptions = {
                    url:'/activity/ajaxUpload',
                    done:function(e, data) {
                        if (data.result.error) {
                            self.uploadFailed(data.result.error);
                        }
                        else {
                            self.loadvegTypeTableOverstorey(data.result.data, self.appendTableRows());
                        }
                    },
                    fail:function(e, data) {
                        var message = 'Please contact MERIT support and attach your spreadsheet to help us resolve the problem';
                        self.uploadFailed(data);

                    },
                    uploadTemplateId: "vegTypeTableOverstoreytemplate-upload",
                    downloadTemplateId: "vegTypeTableOverstoreytemplate-download",
                    formData:{type:'2-ha Track Plot Method', listName:'vegTypeTableOverstorey'}
            };
            self.appendTableRows = ko.observable(true);
            self.uploadFailed = function(message) {
                        var text = "<span class='label label-important'>Important</span><h4>There was an error uploading your data.</h4>";
                        text += "<p>"+message+"</p>";
                        bootbox.alert(text)
            };

            self.data.vegTypeTableUnderstorey = ko.observableArray([]);
            self.selectedvegTypeTableUnderstoreyRow = ko.observable();
        

            self.loadvegTypeTableUnderstorey = function (data, append) {
                if (!append) {
                    self.data.vegTypeTableUnderstorey([]);
                }
                if (data === undefined) {
                                        self.data.vegTypeTableUnderstorey.push(new Output_2haTrackPlotMethod_vegTypeTableUnderstoreyRow({"percentCoverUnderstorey":"","vegTypeUnderstorey":"Main understorey vegetation type","vegDescriptionUnderstorey":""}));
                } else {
                    $.each(data, function (i, obj) {
                        self.data.vegTypeTableUnderstorey.push(new Output_2haTrackPlotMethod_vegTypeTableUnderstoreyRow(obj));
                    });
                }
            };
            self.downloadvegTypeTableUnderstoreyTemplateWithData = function() {
                self.downloadDataTemplate('vegTypeTableUnderstorey');
            }

            self.addvegTypeTableUnderstoreyRow = function () {
                var newRow = new Output_2haTrackPlotMethod_vegTypeTableUnderstoreyRow();
                self.data.vegTypeTableUnderstorey.push(newRow);
                
            };
            self.removevegTypeTableUnderstoreyRow = function (row) {
                self.data.vegTypeTableUnderstorey.remove(row);
                
            };
            self.vegTypeTableUnderstoreyrowCount = function () {
                return self.data.vegTypeTableUnderstorey().length;
            };

            self.vegTypeTableUnderstoreyTableDataUploadVisible = ko.observable(false);
            self.showvegTypeTableUnderstoreyTableDataUpload = function() {
                self.vegTypeTableUnderstoreyTableDataUploadVisible(!self.vegTypeTableUnderstoreyTableDataUploadVisible());
            };

            self.templateDownloadUrl = function(type) {
                return '/proxy/excelOutputTemplate?listName=vegTypeTableUnderstorey&type=2-ha+Track+Plot+Method';
            }

            self.vegTypeTableUnderstoreyTableDataUploadOptions = {
                    url:'/activity/ajaxUpload',
                    done:function(e, data) {
                        if (data.result.error) {
                            self.uploadFailed(data.result.error);
                        }
                        else {
                            self.loadvegTypeTableUnderstorey(data.result.data, self.appendTableRows());
                        }
                    },
                    fail:function(e, data) {
                        var message = 'Please contact MERIT support and attach your spreadsheet to help us resolve the problem';
                        self.uploadFailed(data);

                    },
                    uploadTemplateId: "vegTypeTableUnderstoreytemplate-upload",
                    downloadTemplateId: "vegTypeTableUnderstoreytemplate-download",
                    formData:{type:'2-ha Track Plot Method', listName:'vegTypeTableUnderstorey'}
            };
            self.appendTableRows = ko.observable(true);
            self.uploadFailed = function(message) {
                        var text = "<span class='label label-important'>Important</span><h4>There was an error uploading your data.</h4>";
                        text += "<p>"+message+"</p>";
                        bootbox.alert(text)
            };

            self.data.ephemeralVegPresent = ko.observable();
            self.transients.ephemeralVegPresentConstraints = ["Present","Absent"];

            self.data.timeSinceWeatherEvent = ko.observable();
            self.transients.timeSinceWeatherEventConstraints = ["0 h","<6 h","6-12 h","12.01-24 h",">24 h","Unknown"];

            self.data.timeSinceFire = ko.observable();
            self.transients.timeSinceFireConstraints = ["1-2 years","3-5 years","6-10 years",">10 years","Unknown"];

            self.data.visibility = ko.observable();
            self.transients.visibilityConstraints = ["Distinct shadow","Slight shadow","No shadow"];

            self.data.shadowLength = ko.observable().extend({numericString:2});

            self.data.trackingSurface = ko.observable();
            self.transients.trackingSurfaceConstraints = ["3 - If present, you would be able to distinguish camel, human, dingo, emu or kangaroo tracks only","2 - If present, you would be able to distinguish all of 3 plus fox, cat, rabbit, echidna, large reptiles and goannas","1 - If present, you would be able to distinguish 2 + 3 plus hopping mice, rodent, small bird, insect, etc."];

            self.data.trackingSurfaceSuitability = ko.observable().extend({numericString:2});

            self.data.trackingSurfaceSuitabilityTable = ko.observableArray([]);
            self.selectedtrackingSurfaceSuitabilityTableRow = ko.observable();
        

            self.loadtrackingSurfaceSuitabilityTable = function (data, append) {
                if (!append) {
                    self.data.trackingSurfaceSuitabilityTable([]);
                }
                if (data === undefined) {
                                        self.data.trackingSurfaceSuitabilityTable.push(new Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow({"trackingSurfaceSuitabilityCategory":"Category 1 - could distinguish tracks of category 2 & 3 animals, plus hopping mice, rodents, small birds, insects etc","percentOfPlotSuitable":""}));
                    self.data.trackingSurfaceSuitabilityTable.push(new Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow({"trackingSurfaceSuitabilityCategory":"Category 2 - could distinguish tracks of category 3 animals, plus fox, cat, rabbit, echidna, goannas","percentOfPlotSuitable":""}));
                    self.data.trackingSurfaceSuitabilityTable.push(new Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow({"trackingSurfaceSuitabilityCategory":"Category 3 - could distinguish tracks of camel, dingo, human, emu or kangaroo","percentOfPlotSuitable":""}));
                    self.data.trackingSurfaceSuitabilityTable.push(new Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow({"trackingSurfaceSuitabilityCategory":"Category 4 - no tracks of any animals could be distinguished","percentOfPlotSuitable":""}));
                } else {
                    $.each(data, function (i, obj) {
                        self.data.trackingSurfaceSuitabilityTable.push(new Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow(obj));
                    });
                }
            };
            self.downloadtrackingSurfaceSuitabilityTableTemplateWithData = function() {
                self.downloadDataTemplate('trackingSurfaceSuitabilityTable');
            }

            self.addtrackingSurfaceSuitabilityTableRow = function () {
                var newRow = new Output_2haTrackPlotMethod_trackingSurfaceSuitabilityTableRow();
                self.data.trackingSurfaceSuitabilityTable.push(newRow);
                
            };
            self.removetrackingSurfaceSuitabilityTableRow = function (row) {
                self.data.trackingSurfaceSuitabilityTable.remove(row);
                
            };
            self.trackingSurfaceSuitabilityTablerowCount = function () {
                return self.data.trackingSurfaceSuitabilityTable().length;
            };

            self.trackingSurfaceSuitabilityTableTableDataUploadVisible = ko.observable(false);
            self.showtrackingSurfaceSuitabilityTableTableDataUpload = function() {
                self.trackingSurfaceSuitabilityTableTableDataUploadVisible(!self.trackingSurfaceSuitabilityTableTableDataUploadVisible());
            };

            self.templateDownloadUrl = function(type) {
                return '/proxy/excelOutputTemplate?listName=trackingSurfaceSuitabilityTable&type=2-ha+Track+Plot+Method';
            }

            self.trackingSurfaceSuitabilityTableTableDataUploadOptions = {
                    url:'/activity/ajaxUpload',
                    done:function(e, data) {
                        if (data.result.error) {
                            self.uploadFailed(data.result.error);
                        }
                        else {
                            self.loadtrackingSurfaceSuitabilityTable(data.result.data, self.appendTableRows());
                        }
                    },
                    fail:function(e, data) {
                        var message = 'Please contact MERIT support and attach your spreadsheet to help us resolve the problem';
                        self.uploadFailed(data);

                    },
                    uploadTemplateId: "trackingSurfaceSuitabilityTabletemplate-upload",
                    downloadTemplateId: "trackingSurfaceSuitabilityTabletemplate-download",
                    formData:{type:'2-ha Track Plot Method', listName:'trackingSurfaceSuitabilityTable'}
            };
            self.appendTableRows = ko.observable(true);
            self.uploadFailed = function(message) {
                        var text = "<span class='label label-important'>Important</span><h4>There was an error uploading your data.</h4>";
                        text += "<p>"+message+"</p>";
                        bootbox.alert(text)
            };

            self.data.trackingSurfaceContinuity = ko.observable();
            self.transients.trackingSurfaceContinuityConstraints = ["3 - Majority of sandy patches less than 1m in width","2 - Majority of sandy patches 1-3m in width","1 - Majority of sandy patches more than 3m in width"];

            self.data.sightingEvidenceTable = ko.observableArray([]);
            self.selectedsightingEvidenceTableRow = ko.observable();
        

            self.loadsightingEvidenceTable = function (data, append) {
                if (!append) {
                    self.data.sightingEvidenceTable([]);
                }
                if (data === undefined) {
                    self.addsightingEvidenceTableRow();
                } else {
                    $.each(data, function (i, obj) {
                        self.data.sightingEvidenceTable.push(new Output_2haTrackPlotMethod_sightingEvidenceTableRow(obj));
                    });
                }
            };
            self.downloadsightingEvidenceTableTemplateWithData = function() {
                self.downloadDataTemplate('sightingEvidenceTable');
            }

            self.addsightingEvidenceTableRow = function () {
                var newRow = new Output_2haTrackPlotMethod_sightingEvidenceTableRow();
                self.data.sightingEvidenceTable.push(newRow);
                
            };
            self.removesightingEvidenceTableRow = function (row) {
                self.data.sightingEvidenceTable.remove(row);
                
            };
            self.sightingEvidenceTablerowCount = function () {
                return self.data.sightingEvidenceTable().length;
            };

            self.sightingEvidenceTableTableDataUploadVisible = ko.observable(false);
            self.showsightingEvidenceTableTableDataUpload = function() {
                self.sightingEvidenceTableTableDataUploadVisible(!self.sightingEvidenceTableTableDataUploadVisible());
            };

            self.templateDownloadUrl = function(type) {
                return '/proxy/excelOutputTemplate?listName=sightingEvidenceTable&type=2-ha+Track+Plot+Method';
            }

            self.sightingEvidenceTableTableDataUploadOptions = {
                    url:'/activity/ajaxUpload',
                    done:function(e, data) {
                        if (data.result.error) {
                            self.uploadFailed(data.result.error);
                        }
                        else {
                            self.loadsightingEvidenceTable(data.result.data, self.appendTableRows());
                        }
                    },
                    fail:function(e, data) {
                        var message = 'Please contact MERIT support and attach your spreadsheet to help us resolve the problem';
                        self.uploadFailed(data);

                    },
                    uploadTemplateId: "sightingEvidenceTabletemplate-upload",
                    downloadTemplateId: "sightingEvidenceTabletemplate-download",
                    formData:{type:'2-ha Track Plot Method', listName:'sightingEvidenceTable'}
            };
            self.appendTableRows = ko.observable(true);
            self.uploadFailed = function(message) {
                        var text = "<span class='label label-important'>Important</span><h4>There was an error uploading your data.</h4>";
                        text += "<p>"+message+"</p>";
                        bootbox.alert(text)
            };
            self.transients.site = site;

                // this will be called when generating a savable model to remove transient properties
                self.removeBeforeSave = function (jsData) {
                    // add code to remove any transients added by the dynamic tags
                    
                    delete jsData.activityType;
                    delete jsData.transients;
                    return jsData;
                };

                // this returns a JS object ready for saving
                self.modelForSaving = function () {
                    // get model as a plain javascript object
                    var jsData = ko.mapping.toJS(self, {'ignore':['transients']});
                    if (self.outputNotCompleted()) {
                        jsData.data = {};
                    }
                    // get rid of any transient observables
                    return self.removeBeforeSave(jsData);
                };

                // this is a version of toJSON that just returns the model as it will be saved
                // it is used for detecting when the model is modified (in a way that should invoke a save)
                // the ko.toJSON conversion is preserved so we can use it to view the active model for debugging
                self.modelAsJSON = function () {
                    return JSON.stringify(self.modelForSaving());
                };

                self.loadData = function (data) {
                    // load dynamic data
                                    self.data['recordedBy'](data['recordedBy']);
                self.data['collectedBy'](data['collectedBy']);
                self.data['surveyDate'](data['surveyDate']);
                self.data['plotId'](data['plotId']);
                self.data['sampleType'](data['sampleType']);
                self.data['sampleSequence'](data['sampleSequence']);
                self.data['zone'](orZero(data['zone']));
                self.data['easting'](orZero(data['easting']));
                self.data['northing'](orZero(data['northing']));
                self.data['relativeLocation'](data['relativeLocation']);
                self.data['distanceFromWater'](orZero(data['distanceFromWater']));
                self.data['distanceFromRoad'](orZero(data['distanceFromRoad']));
                self.data['habitatType'](data['habitatType']);
                self.data['habitatTypeOther'](data['habitatTypeOther']);
                self.loadvegTypeTableOverstorey(data.vegTypeTableOverstorey);
                self.loadvegTypeTableUnderstorey(data.vegTypeTableUnderstorey);
                self.data['ephemeralVegPresent'](data['ephemeralVegPresent']);
                self.data['timeSinceWeatherEvent'](data['timeSinceWeatherEvent']);
                self.data['timeSinceFire'](data['timeSinceFire']);
                self.data['visibility'](data['visibility']);
                self.data['shadowLength'](orZero(data['shadowLength']));
                self.data['trackingSurface'](data['trackingSurface']);
                self.data['trackingSurfaceSuitability'](orZero(data['trackingSurfaceSuitability']));
                self.loadtrackingSurfaceSuitabilityTable(data.trackingSurfaceSuitabilityTable);
                self.data['trackingSurfaceContinuity'](data['trackingSurfaceContinuity']);
                self.loadsightingEvidenceTable(data.sightingEvidenceTable);


                    // if there is no data in tables then add an empty row for the user to add data
                    if (typeof self.addRow === 'function' && self.rowCount() === 0) {
                        self.addRow();
                    }
                    self.transients.dummy.notifySubscribers();
                };
            };


            var savedData = activity;
            if (!savedData.outputs) {
                savedData.outputs = [];
            }
            var savedOutput = {};
            if (savedData) {

                $.each(savedData.outputs, function(i, tmpOutput) {
                    if (tmpOutput.name === '2-ha Track Plot Method') {
                        savedOutput = tmpOutput;
                    }
                });
            }

            var config = JSON.parse('\u007b\u0022outputName\u0022:\u00222-ha Track Plot Method\u0022\u002c\u0022optional\u0022:false\u002c\u0022collapsedByDefault\u0022:false\u007d');
            window[viewModelInstance] = new this[viewModelName](savedOutput, config);
            var output = savedOutput.data ? savedOutput.data : {};

            window[viewModelInstance].loadData(output);
            window[viewModelInstance].dirtyFlag = ko.dirtyFlag(window[viewModelInstance], false);

            ko.applyBindings(window[viewModelInstance], document.getElementById("ko2-ha_Track_Plot_Method"));

            // this resets the baseline for detecting changes to the model
            // - shouldn't be required if everything behaves itself but acts as a backup for
            //   any binding side-effects
            // - note that it is not foolproof as applying the bindings happens asynchronously and there
            //   is no easy way to detect its completion
            window[viewModelInstance].dirtyFlag.reset();

            // register with the master controller so this model can participate in the save cycle
            master.register(window[viewModelInstance], window[viewModelInstance].modelForSaving,
            window[viewModelInstance].dirtyFlag.isDirty, window[viewModelInstance].dirtyFlag.reset);
        });

        </script><script type="text/javascript">


    /* Master controller for page. This handles saving each model as required. */
    var Master = function () {
        var self = this;
        this.subscribers = [];
        // client models register their name and methods to participate in saving
        self.register = function (modelInstanceName, getMethod, isDirtyMethod, resetMethod) {
            this.subscribers.push({
                model: modelInstanceName,
                get: getMethod,
                isDirty: isDirtyMethod,
                reset: resetMethod
            });
        };
        // master isDirty flag for the whole page - can control button enabling
        this.isDirty  = function () {
            var dirty = false;
            $.each(this.subscribers, function(i, obj) {
                dirty = dirty || obj.isDirty();
            });
            return dirty;
        };

        this.validate = function() {
            var valid = $('#validation-container').validationEngine('validate');
            if (valid) {
                // Check that forms with multiple optional sections have at least one of those sections completed.
                var optionalCount = 0;
                var notCompletedCount = 0;
                $.each(self.subscribers, function(i, obj) {
                    if (obj.model !== 'activityModel' && obj.model !== 'photoPoints') {
                        if (obj.model.transients.optional) {
                            optionalCount++;
                            if (obj.model.outputNotCompleted()) {
                                notCompletedCount++;
                            }
                        }
                    }
                });
                if (optionalCount > 1 && notCompletedCount == optionalCount) {
                   valid = false;
                   bootbox.alert("<p>To 'Save changes', the mandatory fields of at least one section of this form must be completed.</p>"+
                        "<p>If all sections are 'Not applicable' please contact your grant manager to discuss alternate form options</p>");
                }
            }

            return valid;
        };
        /**
         * Makes an ajax call to save any sections that have been modified. This includes the activity
         * itself and each output.
         *
         * Modified outputs are injected as a list into the activity object. If there is nothing to save
         * in the activity itself, then the root is an object that is empty except for the outputs list.
         *
         * NOTE that the model for each section must register itself to be included in this save.
         *
         * Validates the entire page before saving.
         * @return -1 if the page was not modified, 0 if validation failed, 1 if validation succeeded (or was not requested).
         */
        this.save = function (validate) {
            // Ensure any active change is committed - the knockout binding typically fires on blur.
            $( document.activeElement ).blur();

            if (validate === undefined) {
                validate = true;
            }
            var activityData, outputs = [];

            var success = true;
            if (validate) {
                success = self.validate();
            }
            if (!self.isDirty()) {
                mobileBindings.onSaveActivity(-1, null);
                return -1;
            }
            if (success) {
                $.each(this.subscribers, function(i, obj) {
                    if (obj.model === 'activityModel') {
                        activityData = obj.get();
                    } else {
                        outputs.push(obj.get());
                    }
                });

                if (activityData === undefined) { activityData = {}}
                activityData.outputs = outputs;

                var toSave = JSON.stringify(activityData);
                mobileBindings.onSaveActivity(1, toSave);

            }
            else {
                mobileBindings.onSaveActivity(0, null);
            }
            return success?1:0;
        };

        this.reset = function () {
            $.each(this.subscribers, function(i, obj) {
                if (obj.isDirty()) {
                    obj.reset();
                }
            });
        };

        this.addSite = function(site) {
            var viewModel = ko.dataFor(document.getElementById('site'));
            viewModel.transients.sites.push(site);
            viewModel.siteId(site.siteId);
        }
    };

    if (mobileBindings == undefined) {
        var mobileBindings = {
        
            loadActivity:function(){return "{}"},
        
        
            loadSites:function(){return "[]"},
        
        
            loadThemes:function(){return "[]"},
        

        supportsNewSite:function() { return true; },
        onSaveActivity:function(){},
        createNewSite:function(){}
    };
}
var master = new Master();
var activity = JSON.parse(mobileBindings.loadActivity());
var sites = JSON.parse(mobileBindings.loadSites());
var themes = JSON.parse(mobileBindings.loadThemes());

$(function(){

var scroll = false;

    scroll = true;

$('#validation-container').validationEngine('attach', {scroll: scroll});

$('.helphover').popover({animation: true, trigger:'hover'});

$('#reset').click(function () {
master.reset();
});

function ViewModel (act, sites, themes) {
var self = this;
var today = new Date().toISOStringNoMillis();

self.activityId = act.activityId;
self.description = ko.observable(act.description);
self.notes = ko.observable(act.notes);
self.startDate = ko.observable(act.startDate || today).extend({simpleDate: false});
self.endDate = ko.observable(act.endDate).extend({simpleDate: false});
self.plannedStartDate = ko.observable(act.plannedStartDate).extend({simpleDate: false});
self.plannedEndDate = ko.observable(act.plannedEndDate).extend({simpleDate: false});
self.eventPurpose = ko.observable(act.eventPurpose);
self.fieldNotes = ko.observable(act.fieldNotes);
self.associatedProgram = ko.observable(act.associatedProgram);
self.associatedSubProgram = ko.observable(act.associatedSubProgram);
self.progress = ko.observable(act.progress);
self.mainTheme = ko.observable(act.mainTheme);
self.type = ko.observable(act.type);
self.siteId = ko.observable(act.siteId);
self.projectId = act.projectId;
self.transients = {};
self.transients.sites = ko.observableArray(sites);
self.transients.photoPoints = ko.computed(function() {
    var site = $.grep(self.transients.sites(), function(site, index) { return site.siteId == self.siteId(); })[0];
     if (site) {
         return site.photoPoints ? site.photoPoints : site.poi;
     }
     return [];
});
self.transients.activityProgressValues = ['planned','started','finished'];
self.transients.themes = themes?themes:[];
self.transients.markedAsFinished = ko.observable(act.progress === 'finished');
self.transients.markedAsFinished.subscribe(function (finished) {
    self.progress(finished ? 'finished' : 'started');
    if (finished || !self.endDate()) {
        self.endDate(today);
    }
});
self.transients.siteImgUrl = ko.computed(function() {
    if (self.siteId()) {
         var site = $.grep(self.transients.sites(), function(site, index) { return site.siteId == self.siteId(); })[0];
         if (site) {
            var lat,lon;
            if (site.centroidLat !== undefined && site.centroidLon !== undefined) {
                lat = site.centroidLat;
                lon = site.centroidLon;
            }
            else if (site.extent && site.extent.geometry && site.extent.geometry.centre) {
                lat = site.extent.geometry.centre[1];
                lon = site.extent.geometry.centre[0];
            }
            if (lat !== undefined && lon !== undefined) {
                $('#siteLocationImage').show();
                return fcConfig.googleStaticUrl+lat+","+lon;
            }
         }
    }
    return "";
});
self.siteLoadError = function(data, event) {
    $('#siteLocationImage').hide();
};

self.transients.newSiteSupported = ko.observable( mobileBindings.supportsNewSite());

self.modelForSaving = function () {
    // get model as a plain javascript object
    var jsData = ko.toJS(self);
    delete jsData.transients;
    return jsData;
};
self.modelAsJSON = function () {
    return JSON.stringify(self.modelForSaving());
};

self.save = function (callback, key) {
};

self.createNewSite = function() {
    mobileBindings.createNewSite();
}

self.notImplemented = function () {
    alert("Not implemented yet.")
};

self.attachPhotoPoint = function(e) {
    console.log(e);
};
self.dirtyFlag = ko.dirtyFlag(self, false);

// make sure progress moves to started if we save any data (unless already finished)
// (do this here so the model becomes dirty)
self.progress(self.transients.markedAsFinished() ? 'finished' : 'started');
}


var viewModel = new ViewModel(activity, sites, themes);

ko.applyBindings(viewModel);

master.register('activityModel', viewModel.modelForSaving, viewModel.dirtyFlag.isDirty, viewModel.dirtyFlag.reset);


// Workaround for Android bug 6721 - prevents components under the datepicker from receiving clicks on the datepicker.
var disabled = null;
$('[data-bind^=datepicker]').datepicker().on('show', function() {
    if (disabled == null) {
        disabled = $("input:enabled, select:enabled, button:enabled");
        disabled.prop('disabled', true);
    }
});
$('[data-bind^=datepicker]').datepicker().on('hide', function() {
    if (disabled !== null) {
        disabled.prop('disabled', false);
        disabled = null;
    }
});

});


</script>
</body>
</html>